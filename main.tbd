import core.io
import core.int
import core.string
import core.result
import core.option


fun fibonacci n =
  fun rec aux i prev next =
    let msg = string.from_int next in
    let () = io.println msg in
    match i == n with
    | true -> next
    | false -> 
      (let i = int.add i 1 in
      let next' = int.add prev next in
      aux i next next')
  in aux 0 0 1


enum Direction = 
  | Up of int
  | Down of int
  | Right of int
  | Left of int 
  | None

Direction.Up

fun move d (x, y) = match d with
  | Direction.Up dy -> (x, int.add y dy)
  | Direction.Down dy -> (x, int.sub y dy)
  | Direction.Right dx -> (int.add x dx, y)
  | Direction.Left dx -> (int.sub x dx, y)
  | Direction.None -> (x, y)
  end


fun get_next_dir (x1, y1) (x2, y2) =
  fun norm n = 
    match n with
    | 0 -> 0
    | n -> int.div n (int.abs n)
  in

  let dy = int.sub y1 y2 in
  let dx = int.sub x1 x2 in

  let dy' = 
    match norm dy with
    | 0 -> Direction.None
    | 1 -> Direction.Up (int.abs dy)
    | -1 -> Direction.Down (int.abs dy)
  in

  let dx' = 
    match norm dx with
    | 0 -> Direction.None
    | 1 -> Direction.Right (int.abs dx)
    | -1 -> Direction.Left (int.abs dx)
  in

  (dx', dy')


fun greet p =
  io.println (string.concat "Hello " p.name)


record Person = {
  name : string,
  age : int
}

(* Both works *)
let () =
  greet { name = "John Smith" }


let () =
  let john = Person { name = "John Smith", age = 30 } in
  greet john

let () =
  let father = { name = "John Smith I" } in
  let son = { father with name = "John Smith II" } in
  let () = greet father in
  greet son


module list with
  let x = 12

  fun fold f acc l =
    fun rec aux l' acc =
      match l' with
      | [] -> acc
      | hd::tl -> aux tl (f acc hd)
    in aux l acc

  fun reverse l =
    fun rec aux l' acc =
      match l' with
      | [] -> acc
      | hd::tl -> aux tl (hd::acc)
    in aux l

  fun nth i l =
    fun rec aux l' i' =
      match (int.eq i i', l') with
      | (true, []) -> option.None
      | (true, hd::_) -> option.Some hd
      | (false, _::tl) -> aux tl (int.increment i')
    in aux l 0
    
  fun map f l = reverse (fold (fun acc e -> (f e)::acc) [] l)
  fun sum f zero l = fold f zero l
end

let l = [1, 2, 3, 4, 5]
let total = list.sum int.add 0 l
let doubled = list.map (fun x -> int.mul x 2) l
let collect = list.fold (fun acc e -> e::acc) [] l


let () = io.panic "This is unrecoverable"

let () = match list.nth 3 l with
  | option.None -> io.println "index out of bounds"
  | option.Some x -> io.println (string.from_int x)
  end

let r = result.Error "this is an error value"
let r = result.Ok 42

let () = io.println (string.from_int list.x)


let arr = {0, 1, 2, 3}